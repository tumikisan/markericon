<!DOCTYPE html>
<html>
  <head>
    <title>シンプルな地図</title>
    <style>
      /* ページの余白をなくし、地図を全画面表示にするためのスタイル */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #map {
        height: 100%;
      }

      /* index.html の <style> タグ内 */
      #page-title {
          position: absolute;
          top: 10px;
          left: 50%;
          transform: translateX(-50%); /* ★ 水平方向の中央揃え */
          z-index: 5;
          background-color: rgba(255, 255, 255, 0.8);
          padding: 8px 16px;
          border-radius: 4px;
          font-size: 24px;
          margin: 0;
      }

      .map-button {
            position: absolute;
            z-index: 5;
            background-color: #fff;
            padding: 8px;
            border: 2px solid #fff;
            border-radius: 3px;
            box-shadow: 0 2px 6px rgba(0,0,0,.3);
            cursor: pointer;
            font-family: Roboto, sans-serif;
            font-size: 42px;
            text-align: center;
      }
      .map-button:hover { background-color: #f4f4f4; }//灰色

      .top-button {
          top: 10px;
      }
      .middle-button {
          /* calc()を使って計算 */
          top: 108px; /* 上記の計算結果 */
      }

      /* ★ 各ボタンの位置を設定 */
      #reset-center-button {
            top: 10px;  /* 一番上 */
            right: 10px;
        }
        #start-tracking-button {
           
            right: 10px;
        }
        #stop-tracking-button {
            
            right: 10px;
            display: none;
        }

      /* --- ボトムシート関連のスタイル --- */

      .bottom-sheet-container {
          position: fixed;
          bottom: 0;
          left: 0;
          width: 100%;
          max-height: 60%; /* 画面の高さの最大60%まで */
          background-color: white;
          box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
          border-top-left-radius: 16px;
          border-top-right-radius: 16px;
          
          display: flex;
          flex-direction: column; /* 中の要素を縦に並べる */
          
          transform: translateY(100%); /* ★ 初期状態では画面下に隠す */
          transition: transform 0.3s ease-in-out; /* ★ アニメーション設定 */
          z-index: 1000; /* 他の要素より手前に表示 */
      }

      /* 表示状態にするためのクラス */
      .bottom-sheet-container.is-visible {
          transform: translateY(0); /* ★ 画面内にスライドイン */
      }

      /* ヘッダー部分のスタイル */
      .sheet-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 12px 16px;
          border-bottom: 1px solid #e0e0e0;
          flex-shrink: 0; /* ヘッダーは縮まないようにする */
      }
      .sheet-header h3 {
          margin: 0;
          font-size: 48px;
      }
      #close-sheet-button {
          background: none;
          border: none;
          font-size: 144px;
          cursor: pointer;
          padding: 0 8px;
      }

      /* コンテンツ（部屋リスト）部分のスタイル */
      .sheet-content {
          overflow-y: auto; /* ★ コンテンツがはみ出たらスクロール */
          padding: 8px;
          flex-grow: 1; /* 残りの高さをすべて使う */
      }

      /* 部屋リストの各行のスタイル */
      .room-item {
          display: flex;
          align-items: center;
          padding: 12px 8px;
          border-bottom: 1px solid #f0f0f0;
      }
      .room-item-name {
          flex-grow: 1; /* 部屋番号が残りの幅をすべて使う */
          font-size: 48px;
      }
      .room-item-actions button {
          margin-left: 8px;
          padding: 12px 24px;
          font-size: 48px; 
          border: 1px solid #ccc;
          border-radius: 16px;
          background-color: #f8f9fa;
          cursor: pointer;
      }
      .room-item-actions button.active {
          background-color: #007bff; /* 例：アクティブなボタンの色 */
          color: white;
          border-color: #007bff;
      }

      /* --- 部屋リストのステータス別スタイル --- */

      .room-item.status-refused { /* 拒否 */
          background-color: #f8d7da; /* 薄い赤 */
      }
      .room-item.status-refused .room-item-name {
          color: #721c24; /* 濃い赤 */
          font-weight: bold;
      }

      .room-item.status-long-term-aq { /* 長期 (AQ) */
          background-color: #fff3cd; /* 薄い黄 */
      }
      .room-item.status-long-term-aq .room-item-name {
          color: #856404; /* 濃い黄 */
      }

      .room-item.status-long-term-as { /* 長期 (AT) */
          background-color: #d4edda; /* 薄い緑 */
      }
      .room-item.status-long-term-as .room-item-name {
          color: #155724; /* 濃い緑 */
      }

      .room-item.status-vacant { /* 空 */
          background-color: #e2e3e5; /* 薄い灰色 */
      }
      .room-item.status-vacant .room-item-name {
          color: #383d41; /* 濃い灰色 */
          text-decoration: line-through; /* 取り消し線 */
      }

      /* マーカーのコンテナ（土台）のスタイル */
      .css-marker {
        width: 96px;           /* 幅 */
        height: 96px;          /* 高さ */
        border-radius: 50%;    /* ★ これで要素が正円になる */
        position: relative; /* ★ 重ね合わせの基準にするため */
        box-shadow: 0 2px 4px rgba(0,0,0,0.4); /* 影を追加 */
        cursor: pointer; /* クリックできることを示すカーソル */
      }

      .overlay { /* 共通スタイルをまとめる */
        position: absolute;
        top: 0; 
        left: 0;
        width: 100%; 
        height: 100%;
        border-radius: 50%;
        color: #000000;
        /*font-weight: bold;*/
        display: flex;
        justify-content: center;
        align-items: center;
        /*text-shadow: 2px 3px 5px rgba(0,0,0,0.5); /* 影を共通化 */
        display: none;
      }
      /*transparent透明*/

      /* ★ 個別のスタイル */
      /* ベースとなる文字のスタイル */
      .marker-text {
          font-size: 72px;
      }

      /* レ点と"P"の共通スタイル */
      .checkmark-overlay, .p-overlay {
          font-size: 78px;
          color: #000;
          transform: translate(-10px, -32px);
          
      }

      .apartment-marker, .autolock-marker {
          display: flex; /* これらはtextContentを中央揃えにするために必要 */
          justify-content: center;
          align-items: center;
          font-weight: bold;
      }
      .apartment-marker {
          background-color: white;
          color: #007BFF;
          font-size: 54px;
      }
      .autolock-marker {
          background-color: white;
          color: #6f42c1;
          font-size: 50px;
      }

      /* --- マーカー更新中スタイル --- */
      .spinner {
          border: 8px solid rgba(255, 255, 255, 0.3); /* 薄いボーダー */
          border-radius: 50%;
          border-top: 8px solid #ffffff; /* スピナーの色 */
          width: 64px;
          height: 64px;
          animation: spin 1s linear infinite;
          display: none; /* 初期状態は非表示 */
          position: absolute;
          top: 50%;
          left: 50%;
          margin-top: -32px; /* heightの半分 */
          margin-left: -32px; /* widthの半分 */
      }

      @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
      }

      /* 更新中クラスが付いたマーカーのスタイル */
      .css-marker.is-updating {
          pointer-events: none; /* 更新中はクリックできないようにする */
          opacity: 0.7; /* 少し半透明にする */
      }

      /* 更新中は他のオーバーレイ（文字、✓、P）を隠す */
      .css-marker.is-updating .overlay {
          display: none !important;
      }
      
      /* 更新中クラスが付いたらスピナーを表示 */
      .css-marker.is-updating .spinner {
          display: block;
      }
      
      /* 部屋リストのボタンが無効化された際のスタイル */
      .room-item-actions button:disabled {
          cursor: not-allowed;
          opacity: 0.6;
      }
      /* --- マーカー更新中スタイル ここまで--- */

      /* --- Googleマップの地図/航空写真ボタンのスタイル上書き --- */
     /* --- Googleマップの地図/航空写真ボタンのスタイル上書き (改) --- */
      
      /* ボタンを格納しているコンテナの位置調整 */
      .gm-style-mtc {
          margin: 10px 0 0 10px !important;
          /* 親要素の高さを自動にすることで、中のボタンが大きくなってもはみ出ないようにする */
          height: auto !important; 
      }

      /* ★★★ ボタン自体のスタイルをより強力に指定 ★★★ */
      /* div.gm-style-mtc > button のように、直接の子要素を指定して優先度を上げる */
      div.gm-style-mtc > button {
          height: auto !important; /* 高さはpaddingに任せる */
          width: auto !important;   
          padding: 12px 24px !important; /* ★他のボタンに合わせたpadding */
          background-color: #fff !important;
          border: none !important; /* デフォルトの境界線をリセット */
          box-shadow: 0 2px 6px rgba(0,0,0,.3) !important;
          cursor: pointer !important;
          
          /* ★★★ 文字のスタイルを最優先で指定 ★★★ */
          font-family: Roboto, sans-serif !important;
          font-size: 42px !important; /* ★フォントサイズを強制指定 */
          font-weight: 500 !important;
          color: #222 !important;
          line-height: 1.2 !important; /* 行の高さを調整 */
          display: block !important; /* displayプロパティも念のため指定 */
      }

      /* ボタン間の仕切り線を非表示にする */
      .gm-style-mtc div + div {
          display: none !important;
      }
      
      /* 2つのボタンを隣接させるための調整 */
      .gm-style-mtc button:first-of-type {
          border-radius: 3px 0 0 3px !important;
          margin-right: 0 !important;
      }
      .gm-style-mtc button:last-of-type {
          border-radius: 0 3px 3px 0 !important;
          border-left: 1px solid #ddd !important; /* 間に薄い線を入れる */
      }

      /* 選択されているボタンのスタイル */
      .gm-style-mtc button[aria-pressed="true"] { /* ★セレクタをより正確に */
          background-color: #e0e0e0 !important; 
          color: #000 !important;
      }
      
      /* ホバー時のスタイル */
      .gm-style-mtc button:not([aria-pressed="true"]):hover {
          background-color: #f4f4f4 !important; 
      }

      /* --- Googleマップの地図/航空写真ボタンのスタイル上書きここまで --- */
      

    </style>
  </head>
  <body>
    <h1 id="page-title">Loading...</h1>
    <button id="reset-center-button" class="map-button top-button">初期位置に戻る</button>
    <button id="start-tracking-button" class="map-button middle-button">現在地表示</button>
    <button id="stop-tracking-button" class="map-button middle-button" style="display: none;">現在地非表示</button>
    <button id="force-reload-button" class="map-button" style="top: 206px; right: 10px;">強制更新</button>
    <!-- 地図を表示するための div 要素 -->
    <div id="map"></div>

    <!-- ★★★ ボトムシート用のHTML要素を追加 ★★★ -->
    <div id="bottom-sheet-container" class="bottom-sheet-container">
        <div class="sheet-header">
            <h3 id="sheet-title"></h3>
            <button id="close-sheet-button">&times;</button>
        </div>
        <div id="sheet-content" class="sheet-content">
            <!-- 部屋リストはここに動的に挿入される -->
        </div>
    </div>

    
    <script src="db.js"></script> 
    
    <script>

      // ★ テンプレート構文でGASからIDを受け取る
      const params = new URLSearchParams(window.location.search);
    　const SPREADSHEET_ID = params.get('id'); // URLの'?id=...'の値を取得
      const WEB_APP_URL = "__PLACEHOLDER_WEB_APP_URL__";
      const SECRET_TOKEN = "__PLACEHOLDER_SECRET_TOKEN__";
      const YOUR_API_KEY = "__PLACEHOLDER_YOUR_API_KEY__";

      let map;
      let initialCenterPosition = null;
      let watchId = null; // watchPositionのIDを保存する
      let currentLocationMarker = null; // 現在地マーカーを保存する

      // index.html の <script> タグのグローバルスコープ

      /**
       * ステータス更新を処理する共通関数 (オフライン対応)
       * @param {object} updateOptions - 更新に関する情報
       * @param {function} updateUI - UIを更新するための関数
       * @param {function} rollbackUI - 失敗時にUIを元に戻すための関数
      */

      // ★ ボトムシートの要素を取得
      const bottomSheet = document.getElementById('bottom-sheet-container');
      const sheetTitle = document.getElementById('sheet-title');
      const sheetContent = document.getElementById('sheet-content');
      const closeSheetButton = document.getElementById('close-sheet-button');

      // ★★★ 向きを処理する関数を定義 ★★★
      const handleOrientation = (event) => {
          // マーカーが存在しない場合は何もしない
          if (!currentLocationMarker) return;
          
          // iOS SafariはwebkitCompassHeadingプロパティを持つ (0が真北)
          const heading = event.webkitCompassHeading || event.alpha;
          
          if (heading !== null) {
              const icon = currentLocationMarker.getIcon();
              icon.rotation = heading; // アイコンの回転角度を更新
              currentLocationMarker.setIcon(icon); // 更新したアイコンを再設定
          }
      };

      // ★ Service Workerの登録パスをシンプルに
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./service-worker.js')
              .then(() => console.log('Service Worker registered'));
        }

      function initMap() {
        // IDがURLで指定されていない場合のガード処理
        if (!SPREADSHEET_ID) {
            document.body.innerHTML = "<h1>エラー: 表示するスプレッドシートが指定されていません。</h1><p>URLの末尾に ?id=... を付けてください。</p>";
            return;
        }

        initializeMapAndFeatures(); // 直接初期化処理を開始
      } 

      // [2] アプリの起動シーケンスを管理
      async function initializeMapAndFeatures() {
          try {
            if ('serviceWorker' in navigator && dbManager) {
            // Service WorkerとdbManagerの両方が利用可能な場合のみ実行
                Promise.all([
                    dbManager.setConfig('webAppUrl', WEB_APP_URL),
                    dbManager.setConfig('spreadsheetId', SPREADSHEET_ID),
                    dbManager.setConfig('secretToken', SECRET_TOKEN)
                ]).then(() => {
                    console.log('Configuration saved to IndexedDB for Service Worker.');
                }).catch(err => {
                    console.error('Failed to save config to IndexedDB:', err);
                });
            }
           
            // --- 2. データ取得フロー ---
        let data;
        let features;
        let centerPosition;

        if (navigator.onLine) {
            try {
             
              // オンラインならサーバーから取得
                console.log("Online: Fetching data from server...");
                data = await fetchDataFromServer();
                if (data.error) throw new Error(data.error.message);

               // ★ サーバーから取得した中心座標を最優先で使う
                centerPosition = data.initialCenter;
                features = data.features;

              // 取得したデータをキャッシュ
                await dbManager.cacheFeatures({ features: features, initialCenter: centerPosition });
                console.log("Data cached to IndexedDB.");

                // 溜まっていたキューを同期
                await syncLocalDataWithServer();

              } catch (serverError) {
                console.error("Server fetch failed, falling back to cache:", serverError.message);
                // サーバーがエラーでも、キャッシュがあればフォールバック
                const cachedData = await dbManager.getCachedFeatures();
                if (cachedData) {
                    features = cachedData.features;
                    centerPosition = cachedData.initialCenter; // キャッシュからも中心地を読み込む
                }
            }
        } else {
            // オフラインならキャッシュから読み込む
            console.log("Offline: Loading data from cache...");
            const cachedData = await dbManager.getCachedFeatures();
            if (cachedData) {
                features = cachedData.features;
                centerPosition = cachedData.initialCenter;
            }
        }

        // --- 3. 中心座標が取得できたか最終チェック ---
        if (!centerPosition) {
            // オンラインでもオフラインでも中心地が取得できなかった場合
            document.getElementById('map').innerHTML = 
                '<div style="padding: 2em; text-align: center;"><h2>区域地図データが読み込めませんでした</h2><p>ネットワーク接続を確認して、ページを再読み込みしてください。</p></div>';
            // これ以降の処理は行わない
            return; 
        }

        // ★★★ ここからがタイトル設定の処理 ★★★
        const pageTitle = data.title || "地図"; // data.titleがなければデフォルト値

        // 1. ブラウザのタブのタイトルを変更
        document.title = pageTitle;
        
        // 2. ページ上のh1要素のテキストを変更 (h1要素を追加した場合)
        const titleElement = document.getElementById('page-title');
        if (titleElement) {
            titleElement.textContent = pageTitle;
        }
        // ★★★ タイトル設定ここまで ★★★

        // --- 4. 地図の生成と描画 ---
        // ★ 取得できた中心座標を使って地図を生成
        map = new google.maps.Map(document.getElementById("map"), {
          zoom: 20, // 広域
                  center: centerPosition,
                  mapId: "94c5c628b879c42c946ab547",
                  streetViewControl: false,
                  fullscreenControl: false,
                  zoomControl: false,
                  scaleControl: false,
                  gestureHandling: 'greedy',
                  disableDoubleClickZoom: true
                  // ★★★ ここからが追加・変更部分 ★★★
                  mapTypeControl: true, // MapTypeControlを有効にする
                  mapTypeControlOptions: {
                  // ドロップダウンではなく、横並びのボタンにする
                  style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                  // 位置を左上に指定
                  position: google.maps.ControlPosition.TOP_LEFT,
                  // 表示するマップタイプを指定（これがないと地形なども表示される）
                  mapTypeIds: ['roadmap', 'satellite']
            }
            // ★★★ 追加・変更部分ここまで ★★★
              });

             // グローバル変数に初期位置を保存
        initialCenterPosition = centerPosition;

        if (!features) {
            // 中心座標はあるがマーカーデータがない場合（あり得る）
            console.warn("中心座標は読み込めましたが、マーカーデータはありませんでした。");
        } else {
            drawFeatures(features);
        }

        setupEventListeners();
        
    } catch (error) {
        onFailure(error);
    }
   }

      // [3] サーバーからデータを取得する部分
      // ★ fetchDataFromServerの呼び出し方を修正
      async function fetchDataFromServer() {
          // spreadsheetIdはserverRequestの中で渡されるので、引数は不要
          return await serverRequest('getMapData');
      }
      
      // [4] UIのイベントリスナーをまとめて設定する部分
      function setupEventListeners() {
          const resetButton = document.getElementById('reset-center-button');
          const startButton = document.getElementById("start-tracking-button");
          const stopButton = document.getElementById("stop-tracking-button");

           // ★★★ 強制更新ボタンの要素を取得してイベントを追加 ★★★
          const reloadButton = document.getElementById('force-reload-button');

          // ★★★ ここからが追加するイベントリスナー ★★★
          reloadButton.addEventListener('click', async () => {
              if (!confirm('キャッシュをクリアして地図データを再読み込みしますか？\n（オフライン時の未送信データは保持されます）')) {
                  return; // ユーザーがキャンセルしたら何もしない
              }

              // ユーザーに処理中であることを知らせる
              const titleElement = document.getElementById('page-title');
              titleElement.textContent = '更新中...';
              reloadButton.disabled = true;
              reloadButton.textContent = '更新中';

              try {
                  // 1. IndexedDBの地図データキャッシュをクリア
                  await dbManager.clearCachedFeatures();
                  console.log('Map data cache cleared.');

                  // 2. ページをリロードして、最初からデータを読み直させる
                  //    これにより、initializeMapAndFeatures が再度実行される
                  window.location.reload();

              } catch (error) {
                  console.error('Failed to clear cache and reload:', error);
                  alert('更新処理に失敗しました。');
                  // 失敗した場合はUIを元に戻す
                  titleElement.textContent = document.title; // 元のタイトルに戻す
                  reloadButton.disabled = false;
                  reloadButton.textContent = '強制更新';
              }
          });
          // ★★★ 追加部分ここまで ★★★
          
          resetButton.addEventListener('click', () => {
              if (map && initialCenterPosition) {
                  map.panTo(initialCenterPosition);
                  map.setZoom(20);
              }
          });

          startButton.addEventListener("click", () => {
              if (watchId !== null) return;
              // ... (追跡開始のロジック)
              if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                  // ...
              }
              if (navigator.geolocation) {
                  watchId = navigator.geolocation.watchPosition(// 成功時のコールバック（位置が変わるたびに呼ばれる）
                    (position) => {
                        const pos = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                        };

                        // マーカーがなければ新規作成、あれば位置を更新
                        if (!currentLocationMarker) {
                            currentLocationMarker = new google.maps.Marker({
                                position: pos,
                                map: map,
                                icon: {
                                  path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, // 矢印シンボル
                                  scale: 12,
                                  fillColor: "#4285F4",
                                  fillOpacity: 1,
                                  strokeColor: "white",
                                  strokeWeight: 2,
                                  rotation: 0 // 初期角度
                                    },
                                title: "あなたの現在地"
                            });
                        } else {
                            currentLocationMarker.setPosition(pos);
                        }
                        
                        // 地図の中心をスムーズに移動
                        map.panTo(pos);
                    },
                    // 失敗時のコールバック
                    () => { handleLocationError(true, map.getCenter()); }
                );
                  startButton.style.display = 'none';
                  stopButton.style.display = 'block';
              }
          });

          stopButton.addEventListener("click", () => {
              if (watchId !== null) {
                  navigator.geolocation.clearWatch(watchId);
                  watchId = null;
                  window.removeEventListener('deviceorientation', handleOrientation);
                  if (currentLocationMarker) {
                      currentLocationMarker.setMap(null);
                      currentLocationMarker = null;
                  }
                  startButton.style.display = 'block';
                  stopButton.style.display = 'none';
              }
          });

          closeSheetButton.addEventListener('click', () => {
              bottomSheet.classList.remove('is-visible');
          });
      }
      
      // エラー処理用の関数
      function handleLocationError(browserHasGeolocation, pos) {
          const infoWindow = new google.maps.InfoWindow({
              position: pos,
          });
          infoWindow.setContent(
              browserHasGeolocation
                  ? "エラー: 位置情報サービスに失敗しました。"
                  : "エラー: お使いのブラウザは位置情報サービスに対応していません。"
          );
          infoWindow.open(map);
      }
      
     // ★★★ 修正点2: drawFeatures は features 配列を直接受け取るように変更 ★★★
      function drawFeatures(features) { // 引数名を 'features' に変更して分かりやすく
        // 'data.error' のチェックは initializeMapAndFeatures で済んでいるので不要
        
        // features が配列であり、中身があるかチェック
        if (!features || features.length === 0) {
            console.log("描画するデータがありません。");
            return;
        }

        // ★ features 配列を直接ループ処理
        features.forEach(item => {
            if (item.type === 'apartment') {
                placeApartmentMarker(item);
            } else if (item.type === 'autolock') {
                placeAutolockMarker(item);
            } else if (item.type === 'marker') {
                placeStaticMarker(item);
            } else if (item.type === 'polygon') {
                drawPolygon(item);
            }
        });
      }

      // ===============================================
      // 4. マーカー・ポリゴン描画ヘルパー関数
      // ===============================================

      // ★ マーカー生成を補助するヘルパー関数
      function createAdvancedMarker(markerData, contentDiv) {
          return new google.maps.marker.AdvancedMarkerElement({
              position: { lat: parseFloat(markerData.lat), lng: parseFloat(markerData.lng) },
              map: map,
              content: contentDiv,
              title: markerData.name
          });
      }
      
      // ★★★ スプレッドシートのデータから静的マーカーを配置する新しい関数 ★★★
      function placeStaticMarker(markerData) {
        // --- 1. 定数と状態の定義 ---
        const STATE_DEFAULT = 0;
        const STATE_CHECKED = 1;
        const STATE_P = 2;
        
        const STATUS_VALUES = {
            [STATE_DEFAULT]: "",
            [STATE_CHECKED]: "会えた",
            [STATE_P]: "P"
        };

        // ★★★【追加】マーカーの色を更新するためのヘルパー関数 ★★★
        // この関数を定義することで、初期描画とクリック後の更新で同じロジックを使える
        function updateMarkerColor(div, statusAQ, statusAT) {
            let backgroundColor = "#ffffff"; // デフォルトの色
            if (statusAQ === '長期') {
                backgroundColor = "#FFC107"; // 黄色
            } else if (statusAQ === '拒否') {
                backgroundColor = "#DC3545"; // 赤色
            } else if (statusAQ === '空') {
                backgroundColor = "#343A40"; // 黒に近い色
            } else if (statusAT === '長期') {
                backgroundColor = "#28A745"; // 緑色
            }
            div.style.backgroundColor = backgroundColor;
        }
        
        // 1. マーカーのコンテンツとなるdiv要素を作成
        const markerDiv = document.createElement("div");
        markerDiv.className = "css-marker"; // 上で定義したCSSクラスを適用

        const statusAQ = markerData.statusAQ;
        const statusAS = markerData.statusAS;

        // ★★★ ここの判定ロジックを修正 ★★★
        let backgroundColor = "#ffffff"; // デフォルトの色（白色など）
        let textContent = markerData.name || "?";

        if (statusAQ === '長期') {
            backgroundColor = "#FFC107"; // 黄色 (Bootstrapのwarning色)
        } else if (statusAQ === '拒否') {
            backgroundColor = "#DC3545"; // 赤色 (Bootstrapのdanger色)
        } else if (statusAQ === '空') {
            backgroundColor = "#343A40"; // 黒に近い色 (Bootstrapのdark色)
        } else if (statusAS === '長期') {
            // 上のAQの条件がどれも当てはまらなかった場合のみ、これが評価される
            backgroundColor = "#28A745"; // 緑色 (Bootstrapのsuccess色)
        }

         // ★★★ innerHTMLの生成を一度で行う ★★★
        //マーカーの使用文字
        markerDiv.innerHTML = `
          <div class="overlay marker-text">${textContent.substring(0, 1)}</div>
          <div class="overlay checkmark-overlay">✓</div>
          <div class="overlay p-overlay">P</div>
          <div class="spinner"></div>
        `;
        markerDiv.style.backgroundColor = backgroundColor;
        
        // 3. ★★★ HTML要素を追加した後で、各要素を取得する ★★★
        const textOverlay = markerDiv.querySelector('.marker-text');
        const checkmarkOverlay = markerDiv.querySelector('.checkmark-overlay');
        const pOverlay = markerDiv.querySelector('.p-overlay');

        // ★★★ JSで表示/非表示を明確に制御 ★★★
        textOverlay.style.display = 'flex'; // ベースの文字は常に表示
        
        // ヘルパー関数を呼び出す
        const marker = createAdvancedMarker(markerData, markerDiv);

        // --- 4. クリックイベントのロジックを3段階サイクルに修正 ---

        // a. 初期状態を数値で決定
        let currentState = STATE_DEFAULT;
        if (markerData.initialStateValue === '会えた') {
            currentState = STATE_CHECKED;
        } else if (markerData.initialStateValue === 'P') {
            currentState = STATE_P;
        }

        // b. 初期状態の見た目を反映させる関数
        function updateAppearance(state) {
            checkmarkOverlay.style.display = (state === STATE_CHECKED) ? 'flex' : 'none';
            pOverlay.style.display = (state === STATE_P) ? 'flex' : 'none';
        }
        updateAppearance(currentState); // 初期表示

        // c. クリックイベントリスナー
        markerDiv.addEventListener('click', async () => {
            // 更新中の場合は多重実行を防ぐ
            if (markerDiv.classList.contains('is-updating')) {
                return;
            }

            const oldState = currentState;
            // 状態を次の段階に進める (0 -> 1 -> 2 -> 0)
            const nextState = (currentState + 1) % 3;
            const valueToSet = STATUS_VALUES[nextState];
            const updateOptions = { rowNumber: markerData.rowNumber, valueToSet: valueToSet };

            // --- UIを「更新中」状態にする ---
            markerDiv.classList.add('is-updating');

            try {
                 // ★【変更】サーバー/ローカルDBへの更新処理を待ち、戻り値を受け取る
                const newStatusData = await handleStatusUpdate(updateOptions);

                // --- 成功時の処理 ---
                currentState = nextState;
                updateAppearance(currentState); // UIを新しい状態に更新

                // ★★★【追加】ここからが色を更新するロジック ★★★
                // サーバーから新しいステータスが返ってきた場合のみ色を更新
                if (newStatusData) {
                    // 内部で保持しているデータも更新する（任意ですが推奨）
                    markerData.statusAQ = newStatusData.newStatusAQ;
                    markerData.statusAT = newStatusData.newStatusAT;
                    // ヘルパー関数を使ってマーカーの色を更新
                    updateMarkerColor(markerDiv, newStatusData.newStatusAQ, newStatusData.newStatusAT);
                }
                // ★★★ 追加部分ここまで ★★★

                // 成功したことを視覚的にフィードバック（緑の枠線を1.5秒表示）
                markerDiv.style.outline = '4px solid #28A745';
                setTimeout(() => { markerDiv.style.outline = 'none'; }, 1500);

            } catch (error) {
                // --- 失敗時の処理 ---
                console.error('Update failed:', error);
                // UIは変更せず、元の状態を維持
                updateAppearance(oldState); 
                alert(error.message || 'データの更新に失敗しました。');

                // 失敗したことを視覚的にフィードバック（赤の枠線を2秒表示）
                markerDiv.style.outline = '4px solid #DC3545';
                setTimeout(() => { markerDiv.style.outline = 'none'; }, 2000);
            
            } finally {
                // --- 成功・失敗に関わらずUIを通常状態に戻す ---
                markerDiv.classList.remove('is-updating');
            }
        });

        /*

        // c. クリックイベントリスナー
        markerDiv.addEventListener('click', () => {
           const oldState = currentState;
            // 状態を次の段階に進める (0 -> 1 -> 2 -> 0)
            //currentState = (currentState + 1) % 3;
            
            // 見た目を即座に更新
            updateAppearance(currentState);
            
            // スプレッドシートに書き込む値を取得
            currentState = (currentState + 1) % 3;
            const valueToSet = STATUS_VALUES[currentState];

             // ★★★ ここを差し替え ★★★
            handleStatusUpdate(
                { rowNumber: markerData.rowNumber, valueToSet: valueToSet }, // 更新オプション
                () => updateAppearance(currentState), // UI更新関数
                () => { // ロールバック関数
                    currentState = oldState;
                    updateAppearance(oldState);
                }
            );
        });

        */
          
        
      }

      function drawPolygon(polygonData) {
        const rawData = polygonData.rawData;
        let wkt = '';
        let name = '';

        // "))," を区切り文字としてWKTと名前を分離するロジック
        const wktEndDelimiter = ')),';
        const delimiterIndex = rawData.indexOf(wktEndDelimiter);

        if (delimiterIndex !== -1) {
            // WKT部分は "POLYGON..." から "))" まで
            wkt = rawData.substring(0, delimiterIndex + 2); // "))" の2文字分を含める
            // 名前部分は、区切り文字の後から始まり、最後のカンマを取り除く
            name = rawData.substring(delimiterIndex + wktEndDelimiter.length).replace(/,$/, '').trim();
        } else {
            // 区切り文字が見つからない場合は、全体がWKTデータだと仮定する
            wkt = rawData;
            name = '名前なし';
        }


        const coordString = wkt.match(/\(\((.*)\)\)/);
        
        if (!coordString || !coordString[1]) {
          console.error("解析後のWKTデータが無効です:", wkt);
          return;
        }  
        const path = coordString[1].split(',').map(pair => {
            const coords = pair.trim().split(' ');
            return { lat: parseFloat(coords[1]), lng: parseFloat(coords[0]) };
        });
        const polygon = new google.maps.Polygon({
            paths: path,
            strokeColor: "#000000",
            strokeOpacity: 1.0,
            strokeWeight: 2,
            fillOpacity: 0.0,
            map: map,
            clickable: false,
        });
        // (ポリゴンのクリックイベントなども必要ならここに追加)
      }

      // --- アパートマーカーを配置する関数を修正 ---
      function placeApartmentMarker(apartmentData) {
          const markerDiv = document.createElement("div");
          markerDiv.className = "css-marker apartment-marker";
          const displayText = apartmentData.key + "A"; 
          markerDiv.textContent = displayText;
        
          const marker = createAdvancedMarker(apartmentData, markerDiv);

          // ★ クリックイベントでボトムシートを表示する関数を呼び出す
          marker.content.addEventListener('click', () => {
              showBottomSheet(apartmentData);
          });
      }

      // ★★★【追加】オートロック区域マーカーを配置する関数 ★★★
      function placeAutolockMarker(markerData) {
          const markerDiv = document.createElement("div");
          markerDiv.className = "css-marker autolock-marker"; // 基本的なスタイル（円形、サイズなど）を適用
          const displayText = markerData.key + "A"; 
          markerDiv.textContent = displayText;

          // オートロック用の特別なスタイルを設定
          //markerDiv.style.backgroundColor = "#6f42c1"; // 紫色
          //markerDiv.style.color = "white";
          //markerDiv.textContent = "A";

          const marker = new google.maps.marker.AdvancedMarkerElement({
              position: { lat: parseFloat(markerData.lat), lng: parseFloat(markerData.lng) },
              map: map,
              content: markerDiv,
              title: markerData.name
          });

          // オートロックマーカーはクリックイベントを持たない
      }

      // ★★★ ボトムシートを表示・制御する新しい関数 ★★★
      function showBottomSheet(apartmentData) {
          // 1. タイトルを設定
          sheetTitle.textContent = apartmentData.name;
          
          // 2. コンテンツエリアを一旦空にする
          sheetContent.innerHTML = '';

          // 3. 部屋リストを生成
          apartmentData.rooms.forEach(room => {
              const roomItem = document.createElement('div');

              // --- ★★★ ここからがステータス判定とクラス割り当て ★★★ ---
              let statusClass = ''; // デフォルトはクラスなし

              // 優先順位に従って判定
              if (room.statusAQ === '拒否') {
                  statusClass = 'status-refused';
              } else if (room.statusAQ === '長期') {
                  statusClass = 'status-long-term-aq';
              } else if (room.statusAQ === '空') {
                  statusClass = 'status-vacant';
              } else if (room.statusAS === '長期') {
                  statusClass = 'status-long-term-as';
              }

              // 判定されたクラスを room-item に追加
              roomItem.className = `room-item ${statusClass}`;
              // --- ★★★ 判定ロジックここまで ★★★ ---

              //roomItem.className = 'room-item';
              
              // ★ 各部屋のHTMLを生成
              roomItem.innerHTML = `
                  <div class="room-item-name">${room.room}</div>
                  <div class="room-item-actions">
                      <button data-status="会えた" class="${room.status === '会えた' ? 'active' : ''}">会</button>
                      <button data-status="P" class="${room.status === 'P' ? 'active' : ''}">P</button>
                  </div>
              `;

            // 4. ステータス変更ボタンにイベントを追加
              roomItem.querySelectorAll('.room-item-actions button').forEach(button => {
                  button.addEventListener('click', async () => { // ★ async を追加
                      const allButtons = button.closest('.room-item-actions').querySelectorAll('button');

                      // 更新中の場合は多重実行を防ぐ
                      if (allButtons[0].disabled) return;

                      // 1. まず、現在の状態を保存しておく（失敗時のロールバック用）
                      const oldStatus = room.status;

                      // 2. 新しい状態を計算
                      const newStatus = button.dataset.status;
                      const valueToSet = (oldStatus === newStatus) ? "" : newStatus;
                      const updateOptions = { rowNumber: room.row, valueToSet: valueToSet };
                      
                      // --- UIを「更新中」状態にする ---
                      allButtons.forEach(b => b.disabled = true);

                      try {
                          // サーバー/ローカルDBへの更新処理を待つ
                          await handleStatusUpdate(updateOptions);

                          // --- 成功時の処理 ---
                          room.status = valueToSet;
                          updateRoomListAppearance(apartmentData);

                      } catch(error) {
                          // --- 失敗時の処理 ---
                          console.error('Update failed:', error);
                          alert(error.message || 'データの更新に失敗しました。');
                          // 状態を元に戻してUIを再描画
                          room.status = oldStatus;
                          updateRoomListAppearance(apartmentData);

                      } finally {
                          // --- 成功・失敗に関わらずUIを通常状態に戻す ---
                          allButtons.forEach(b => b.disabled = false);
                      }
                });
              });

            /*

              // 4. ステータス変更ボタンにイベントを追加
              roomItem.querySelectorAll('.room-item-actions button').forEach(button => {
                  button.addEventListener('click', () => {
                      // クリックされたボタンのステータスを取得
                      //const newStatus = button.dataset.status;
                      
                     // ★★★ 楽観的UI更新のロジック ★★★
    
                      // 1. まず、現在の状態を保存しておく（失敗時のロールバック用）
                      const oldStatus = room.status;

                      // 2. 新しい状態を計算し、ローカルデータを更新
                      const newStatus = button.dataset.status;
                      const valueToSet = (oldStatus === newStatus) ? "" : newStatus;
                      room.status = valueToSet;

                      // ★★★ ここを差し替え ★★★
                      handleStatusUpdate(
                          { rowNumber: room.row, valueToSet: valueToSet }, // 更新オプション
                          () => { // UI更新関数
                              room.status = valueToSet;
                              updateRoomListAppearance(apartmentData);
                          },
                          () => { // ロールバック関数
                              room.status = oldStatus;
                              updateRoomListAppearance(apartmentData);
                          }
                      );
                });
              });

              */

              sheetContent.appendChild(roomItem);
          });

          // 5. ボトムシートを表示
          bottomSheet.classList.add('is-visible');
      }

      // ★ 部屋リストの見た目を更新する補助関数
      function updateRoomListAppearance(apartmentData) {
          // 現在表示されているアパートが正しいかチェック
          if (sheetTitle.textContent !== apartmentData.name) return;

          sheetContent.querySelectorAll('.room-item').forEach((item, index) => {
              const room = apartmentData.rooms[index];
              const buttons = item.querySelectorAll('.room-item-actions button');
              buttons.forEach(button => {
                  if (button.dataset.status === room.status) {
                      button.classList.add('active');
                  } else {
                      button.classList.remove('active');
                  }
              });
          });
      }

      // ===============================================
      // 6. オフライン・同期処理関連ヘルパー関数
      // ===============================================

      // ★★★ この位置に配置するのが適切 ★★★
      async function syncLocalDataWithServer() {
            const queue = await dbManager.getQueue();
         // ★★★ デバッグコードを追加 ★★★
          console.log("--- syncLocalDataWithServer ---");
          console.log("getQueueから受け取ったqueue:", queue);
          console.log("queueは配列ですか？:", Array.isArray(queue));
          // ★★★ デバッグコードここまで ★★★

          if (!queue || !Array.isArray(queue) || queue.length === 0) {
              // !Array.isArray(queue) を追加して、配列でない場合はここで弾く
              console.log("同期するデータは配列ではない、または空です。");
              return;
          }
        
            if (!queue || queue.length === 0) return;
            const updates = queue.map(item => ({ row: item.rowNumber, status: item.valueToSet }));

            try {
                await serverRequest('batchUpdateStatuses', { updates: updates });
                await dbManager.clearQueue();
                console.log("Sync successful!");
            } catch (error) {
                console.error("Sync failed:", error.message);
            }
        }

      // ★★★ 新しいserverRequest関数 ★★★
      async function serverRequest(action, payload = {}) {
        try {
          // ★★★ プリフライト代わりのGETリクエストは削除 ★★★
          
          const response = await fetch(WEB_APP_URL, {
              method: 'POST',
              mode: 'cors', 
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  action,
                  token: SECRET_TOKEN,
                  spreadsheetId: SPREADSHEET_ID, // ★ spreadsheetIdもここで渡す
                  ...payload
              })
          });
          const result = await response.json();
          if (!response.ok || !result.success) {
              throw new Error(result.message || 'Server request failed');
          }
          return result.data;
        } catch (error) {
            console.error('serverRequest Error:', error);
            throw error;
        }
      }

      async function handleStatusUpdate(updateOptions, updateUI, rollbackUI) {
         // オンラインの場合、直接サーバーにリクエストして完了を待つ
        if (navigator.onLine) {
            try {
                const updates = [{ row: updateOptions.rowNumber, status: updateOptions.valueToSet }];
                // ★サーバーからの戻り値を受け取る
                const resultData = await serverRequest('batchUpdateStatuses', { updates: updates });
                console.log("Online update successful. Server response:", resultData);
                // ★結果を呼び出し元に返す (今回は1件ずつの更新なので最初の要素を返す)
                return resultData[0];
            } catch (error) {
                // オンラインでもサーバーリクエストが失敗した場合、フォールバックとしてキューに追加
                console.warn("Online update failed, falling back to queue.", error);
                await dbManager.putToQueue(updateOptions);
                // Background Syncに登録を試みる
                if ('serviceWorker' in navigator && 'SyncManager' in window) {
                    const sw = await navigator.serviceWorker.ready;
                    await sw.sync.register('sync-updates');
                }
                // 即時更新には失敗したことを呼び出し元に伝えるためにエラーを投げる
                throw new Error("サーバーとの通信に失敗しました。変更は後で同期されます。");
            }
        } else {
            // オフラインの場合、キューに入れるだけ
            console.log("Offline, update queued.");
            await dbManager.putToQueue(updateOptions);
            // Background Syncに登録を試みる
            if ('serviceWorker' in navigator && 'SyncManager' in window) {
                const sw = await navigator.serviceWorker.ready;
                await sw.sync.register('sync-updates');
            }
            // オフライン時はサーバーからデータが返らないのでnullを返す
            return null;
        }
      }

        /*
        
         // オンラインの場合、直接サーバーにリクエストして完了を待つ
        if (navigator.onLine) {
            try {
                const updates = [{ row: updateOptions.rowNumber, status: updateOptions.valueToSet }];
                await serverRequest('batchUpdateStatuses', { updates: updates });
                console.log("Online update successful.");
            } catch (error) {
                // オンラインでもサーバーリクエストが失敗した場合、フォールバックとしてキューに追加
                console.warn("Online update failed, falling back to queue.", error);
                await dbManager.putToQueue(updateOptions);
                // Background Syncに登録を試みる
                if ('serviceWorker' in navigator && 'SyncManager' in window) {
                    const sw = await navigator.serviceWorker.ready;
                    await sw.sync.register('sync-updates');
                }
                // 即時更新には失敗したことを呼び出し元に伝えるためにエラーを投げる
                throw new Error("サーバーとの通信に失敗しました。変更は後で同期されます。");
            }
        } else {
            // オフラインの場合、キューに入れるだけ
            console.log("Offline, update queued.");
            await dbManager.putToQueue(updateOptions);
            // Background Syncに登録を試みる
            if ('serviceWorker' in navigator && 'SyncManager' in window) {
                const sw = await navigator.serviceWorker.ready;
                await sw.sync.register('sync-updates');
            }
            // オフライン時は即時更新できないが、処理は成功とみなし、UIは更新させる
        }
      }

        
        
        // 1. 楽観的UI更新：まず見た目を先に変える
        updateUI();
        
        // 2. 更新内容をキュー(IndexedDB)に追加
        // updateOptionsには { rowNumber, valueToSet } などが含まれる
        await dbManager.putToQueue(updateOptions);
        
        // 3. バックグラウンド同期をリクエスト
        try {
          if ('serviceWorker' in navigator && 'SyncManager' in window) {
            const sw = await navigator.serviceWorker.ready;
            await sw.sync.register('sync-updates');
            console.log('Background sync registered');
          } else {
            // SyncManager非対応ブラウザ用のフォールバック
            if (navigator.onLine) {
              await syncLocalDataWithServer();
            }
          }
        } catch (error) {
          console.error('Failed to handle status update:', error);
          // もし同期リクエスト自体に失敗したら、UIを元に戻す
          rollbackUI();
          alert('更新リクエストの処理中にエラーが発生しました。');
        }
      }

      */

      function onFailure(error) {
            alert("データの読み込みに失敗しました。\n詳細: " + error.message);
            console.error(error);
      }

      // 2. 新しい<script>要素を動的に生成する
        const googleMapsScript = document.createElement('script');
        
        // 3. src属性に、APIキーを含んだURLを設定する
        googleMapsScript.src = `https://maps.googleapis.com/maps/api/js?key=${YOUR_API_KEY}&callback=initMap&libraries=marker`;
        
        // 4. defer属性を設定して、非同期で読み込むようにする
        googleMapsScript.defer = true;
        googleMapsScript.async = true;
        
        // 5. 生成した<script>要素を、ドキュメントの<head>の末尾に追加する
        document.body.appendChild(googleMapsScript);

      
    </script>
  </body>
</html>





